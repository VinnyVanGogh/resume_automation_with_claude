"""
DOCX generator for resume output.

This module provides the DOCXGenerator class for creating professional,
ATS-compliant Word documents using python-docx.
"""

import logging
from pathlib import Path
from typing import Optional, Dict, Any, List
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.style import WD_STYLE_TYPE
from docx.oxml.shared import OxmlElement, qn

from src.models import ResumeData, Experience, Education, Project, Certification, Skills
from .config import DOCXConfig, OutputConfig


logger = logging.getLogger(__name__)


class DOCXGenerator:
    """
    Generate DOCX resume output from structured resume data.
    
    This class uses python-docx to create professional Word documents
    with ATS-compliant formatting and consistent styling.
    """
    
    def __init__(self, config: Optional[DOCXConfig] = None) -> None:
        """
        Initialize DOCX generator with configuration.
        
        Args:
            config: DOCX generation configuration. If None, uses defaults.
        """
        self.config = config or DOCXConfig()
        logger.info("DOCXGenerator initialized")
    
    def generate(
        self, 
        resume_data: ResumeData, 
        output_path: Optional[Path] = None,
        template_vars: Optional[Dict[str, Any]] = None
    ) -> bytes:
        """
        Generate DOCX resume from structured resume data.
        
        Args:
            resume_data: Validated resume data from Phase 3 formatter
            output_path: Optional path to save DOCX file
            template_vars: Additional template variables (unused for DOCX)
            
        Returns:
            bytes: Generated DOCX content as bytes
            
        Raises:
            ValueError: If resume data is invalid
            RuntimeError: If DOCX generation fails
        """
        logger.info("Starting DOCX generation")
        
        # Validate input data
        if not isinstance(resume_data, ResumeData):
            raise ValueError("resume_data must be a ResumeData instance")
        
        try:
            # Create new document
            doc = Document()
            
            # Configure document properties
            self._set_document_properties(doc, resume_data)
            
            # Configure document styling
            self._configure_document_styles(doc)
            
            # Set margins
            self._set_page_margins(doc)
            
            # Add content sections
            self._add_header_section(doc, resume_data)
            
            if resume_data.summary:
                self._add_summary_section(doc, resume_data.summary)
            
            if resume_data.experience:
                self._add_experience_section(doc, resume_data.experience)
            
            if resume_data.education:
                self._add_education_section(doc, resume_data.education)
            
            if resume_data.skills:
                self._add_skills_section(doc, resume_data.skills)
            
            if resume_data.projects:
                self._add_projects_section(doc, resume_data.projects)
            
            if resume_data.certifications:
                self._add_certifications_section(doc, resume_data.certifications)
            
            # Save to file if path provided
            if output_path:
                output_path.parent.mkdir(parents=True, exist_ok=True)
                doc.save(output_path)
                logger.info(f"DOCX resume saved to: {output_path}")
            
            # Return as bytes for consistency with other generators
            from io import BytesIO
            doc_bytes = BytesIO()
            doc.save(doc_bytes)
            doc_content = doc_bytes.getvalue()
            
            logger.info("DOCX generation completed successfully")
            return doc_content
            
        except Exception as e:
            logger.error(f"Error generating DOCX: {e}")
            raise RuntimeError(f"DOCX generation failed: {e}") from e
    
    def _set_document_properties(self, doc: Document, resume_data: ResumeData) -> None:
        """
        Set document properties and metadata.
        
        Args:
            doc: Document object to configure
            resume_data: Resume data for metadata
        """
        core_props = doc.core_properties
        core_props.title = f"{resume_data.contact.name} - Resume"
        core_props.author = resume_data.contact.name
        core_props.subject = "Professional Resume"
        core_props.keywords = "resume, cv, professional"
        core_props.comments = "Generated by Resume Automation Tool"
    
    def _configure_document_styles(self, doc: Document) -> None:
        """
        Configure document-wide styles for professional appearance.
        
        Args:
            doc: Document object to configure
        """
        styles = doc.styles
        
        # Configure Normal style
        normal_style = styles['Normal']
        normal_font = normal_style.font
        normal_font.name = self.config.font_name
        normal_font.size = Pt(self.config.font_size)
        
        # Configure paragraph spacing
        normal_paragraph = normal_style.paragraph_format
        normal_paragraph.space_after = Pt(6)
        normal_paragraph.line_spacing = self.config.line_spacing
        
        # Create/modify Heading styles
        self._configure_heading_styles(styles)
    
    def _configure_heading_styles(self, styles) -> None:
        """
        Configure heading styles for sections.
        
        Args:
            styles: Document styles collection
        """
        # Heading 1 (Name)
        h1_style = styles['Heading 1']
        h1_font = h1_style.font
        h1_font.name = self.config.font_name
        h1_font.size = Pt(20)
        h1_font.bold = True
        h1_paragraph = h1_style.paragraph_format
        h1_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
        h1_paragraph.space_after = Pt(6)
        
        # Heading 2 (Section headers)
        h2_style = styles['Heading 2']
        h2_font = h2_style.font
        h2_font.name = self.config.font_name
        h2_font.size = Pt(14)
        h2_font.bold = True
        h2_paragraph = h2_style.paragraph_format
        h2_paragraph.space_before = Pt(self.config.section_spacing)
        h2_paragraph.space_after = Pt(6)
        
        # Add border to Heading 2
        self._add_heading_border(h2_style)
        
        # Heading 3 (Job titles, etc.)
        h3_style = styles['Heading 3']
        h3_font = h3_style.font
        h3_font.name = self.config.font_name
        h3_font.size = Pt(12)
        h3_font.bold = True
        h3_paragraph = h3_style.paragraph_format
        h3_paragraph.space_before = Pt(8)
        h3_paragraph.space_after = Pt(4)
    
    def _add_heading_border(self, style) -> None:
        """
        Add bottom border to heading style.
        
        Args:
            style: Style object to modify
        """
        try:
            # This is a complex operation in python-docx
            # For simplicity, we'll skip the border for now
            # In production, you might want to implement this fully
            pass
        except Exception as e:
            logger.warning(f"Could not add heading border: {e}")
    
    def _set_page_margins(self, doc: Document) -> None:
        """
        Set page margins according to configuration.
        
        Args:
            doc: Document object to configure
        """
        sections = doc.sections
        for section in sections:
            section.top_margin = Inches(self.config.margin_top)
            section.bottom_margin = Inches(self.config.margin_bottom)
            section.left_margin = Inches(self.config.margin_left)
            section.right_margin = Inches(self.config.margin_right)
    
    def _add_header_section(self, doc: Document, resume_data: ResumeData) -> None:
        """
        Add header section with contact information.
        
        Args:
            doc: Document object
            resume_data: Resume data
        """
        contact = resume_data.contact
        
        # Name as title
        name_para = doc.add_heading(contact.name, level=1)
        
        # Contact information
        contact_lines = []
        
        # Email and phone
        email_phone = []
        if contact.email:
            email_phone.append(str(contact.email))
        if contact.phone:
            email_phone.append(contact.phone)
        if email_phone:
            contact_lines.append(" | ".join(email_phone))
        
        # URLs
        url_line = []
        if contact.linkedin:
            url_line.append(str(contact.linkedin))
        if contact.github:
            url_line.append(str(contact.github))
        if contact.website:
            url_line.append(str(contact.website))
        if url_line:
            contact_lines.append(" | ".join(url_line))
        
        # Location
        if contact.location:
            contact_lines.append(contact.location)
        
        # Add contact lines
        for line in contact_lines:
            para = doc.add_paragraph(line)
            para.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    def _add_summary_section(self, doc: Document, summary: str) -> None:
        """
        Add professional summary section.
        
        Args:
            doc: Document object
            summary: Summary text
        """
        doc.add_heading("Summary", level=2)
        doc.add_paragraph(summary)
    
    def _add_experience_section(self, doc: Document, experiences: List[Experience]) -> None:
        """
        Add experience section.
        
        Args:
            doc: Document object
            experiences: List of experience items
        """
        doc.add_heading("Experience", level=2)
        
        for exp in experiences:
            # Job title and company
            title_para = doc.add_heading(f"{exp.title} | {exp.company}", level=3)
            
            # Dates and location
            date_location = []
            if exp.start_date:
                end_date = exp.end_date or "Present"
                date_location.append(f"{exp.start_date} - {end_date}")
            if exp.location:
                date_location.append(exp.location)
            
            if date_location:
                date_para = doc.add_paragraph(" | ".join(date_location))
                date_run = date_para.runs[0]
                date_run.italic = True
            
            # Responsibilities (bullets field in Experience model)
            if exp.bullets:
                for responsibility in exp.bullets:
                    # Use bullet points (• character)
                    bullet_para = doc.add_paragraph(f"• {responsibility}")
                    bullet_para.paragraph_format.left_indent = Inches(0.25)
    
    def _add_education_section(self, doc: Document, education: List[Education]) -> None:
        """
        Add education section.
        
        Args:
            doc: Document object
            education: List of education items
        """
        doc.add_heading("Education", level=2)
        
        for edu in education:
            # Degree and school
            title_para = doc.add_heading(f"{edu.degree} | {edu.school}", level=3)
            
            # Dates and location
            date_info = []
            if edu.start_date:
                end_date = edu.end_date or "Present"
                date_info.append(f"{edu.start_date} - {end_date}")
            if edu.location:
                date_info.append(edu.location)
            
            if date_info:
                date_para = doc.add_paragraph(" | ".join(date_info))
                date_run = date_para.runs[0]
                date_run.italic = True
            
            # GPA if provided
            if edu.gpa:
                gpa_para = doc.add_paragraph(f"GPA: {edu.gpa}")
            
            # Relevant coursework or details
            if edu.coursework:
                for course in edu.coursework:
                    bullet_para = doc.add_paragraph(f"• {course}")
                    bullet_para.paragraph_format.left_indent = Inches(0.25)
    
    def _add_skills_section(self, doc: Document, skills: Skills) -> None:
        """
        Add skills section.
        
        Args:
            doc: Document object
            skills: Skills model instance
        """
        doc.add_heading("Skills", level=2)
        
        # Handle categorized skills
        if skills.categories:
            for skill_category in skills.categories:
                if skill_category.skills:
                    skills_text = ", ".join(skill_category.skills)
                    para = doc.add_paragraph()
                    
                    # Add category in bold
                    category_run = para.add_run(f"{skill_category.name}: ")
                    category_run.bold = True
                    
                    # Add skills
                    para.add_run(skills_text)
        
        # Handle raw skills list
        elif skills.raw_skills:
            skills_text = ", ".join(skills.raw_skills)
            para = doc.add_paragraph(skills_text)
    
    def _add_projects_section(self, doc: Document, projects: List[Project]) -> None:
        """
        Add projects section.
        
        Args:
            doc: Document object
            projects: List of project items
        """
        doc.add_heading("Projects", level=2)
        
        for project in projects:
            # Project name
            title_para = doc.add_heading(project.name, level=3)
            
            # Technologies
            if project.technologies:
                tech_text = ", ".join(project.technologies)
                tech_para = doc.add_paragraph()
                tech_run = tech_para.add_run(f"Technologies: ")
                tech_run.bold = True
                tech_para.add_run(tech_text)
            
            # Description
            if project.description:
                doc.add_paragraph(project.description)
            
            # URL
            if project.url:
                url_para = doc.add_paragraph(f"URL: {project.url}")
    
    def _add_certifications_section(self, doc: Document, certifications: List[Certification]) -> None:
        """
        Add certifications section.
        
        Args:
            doc: Document object
            certifications: List of certification items
        """
        doc.add_heading("Certifications", level=2)
        
        for cert in certifications:
            # Certification name and issuer
            cert_para = doc.add_paragraph()
            
            # Name in bold
            name_run = cert_para.add_run(cert.name)
            name_run.bold = True
            
            # Issuer
            if cert.issuer:
                cert_para.add_run(f" - {cert.issuer}")
            
            # Date
            if cert.date:
                cert_para.add_run(f" ({cert.date})")
            
            # URL (if available)
            if hasattr(cert, 'url') and cert.url:
                url_para = doc.add_paragraph(f"Verification: {cert.url}")
    
    def validate_output(self, docx_bytes: bytes) -> bool:
        """
        Validate generated DOCX for basic compliance.
        
        Args:
            docx_bytes: DOCX content to validate
            
        Returns:
            bool: True if validation passes
            
        Raises:
            ValueError: If validation fails
        """
        # Basic DOCX validation
        if not docx_bytes:
            raise ValueError("DOCX content is empty")
        
        # Check for DOCX file signature (ZIP format)
        if not docx_bytes.startswith(b'PK'):
            raise ValueError("Invalid DOCX format - missing ZIP signature")
        
        # Check minimum size
        if len(docx_bytes) < 5000:
            raise ValueError("DOCX file too small - possible generation error")
        
        logger.info("DOCX validation passed")
        return True
    
    @classmethod
    def from_config(cls, config: OutputConfig) -> "DOCXGenerator":
        """
        Create DOCXGenerator from OutputConfig.
        
        Args:
            config: Output configuration containing DOCX config
            
        Returns:
            DOCXGenerator: Configured generator instance
        """
        return cls(config.docx)